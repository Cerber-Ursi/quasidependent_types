Системы типов - это настоящее безумие.

![КДПВ в подражание XKCD](https://habrastorage.org/webt/y0/cp/de/y0cpdecpzjvzezlr09zet6hvtfw.png)

Некоторое время назад я уже отметился здесь со статьёй, в которой пытался разобрать, какие гарантии в compile-time может дать система типов Rust. Кое-какие интересные моменты удалось выловить уже тогда, однако больше всего меня зацепил весьма развёрнутый [комментарий](https://habr.com/ru/post/468145/#comment_20652891), описывающий некоторые вещи, доступные в зависимо-типизированном Idris.
Разумеется, я не мог остаться в стороне. Результат исследований доступен [на github](https://github.com/Cerberuser/quazidependent_types), а детальный разбор - под катом.

<cut/>

Сразу должен оговориться: само собой, *настоящие* зависимые типы в Rust, скорее всего, не реализуемы. Однако мы можем определить *псевдозависимые*, или *квазизависимые* (отсюда и название репозитория) типы, например, следующим образом:

> Пусть у нас имеется некоторое *семейство* типов, состоящее из отдельных типов, далее - *тип-экземпляр*. Назовём это семейство **квазизависимым типом**, если для каждого типа-экземпляра при использовании в безопасном коде гарантируется поддержание некоторого инварианта, полностью определяемого конкретным типом-экземпляром.

Заметим, что формально под это определение подходит достаточно большое количество уже существующих типов - так, если мы рассмотрим "семейство", состоящее из одного типа `str`, мы формально можем сказать, что это семейство является квазизависимым типом - ведь тип `str` гарантирует, что его содержимое - валидный UTF-8. Но такие случаи нам, очевидно, не интересны, поэтому мы немного уточним определение:

> **Семейством типов** назовём одно из двух:
> - либо набор всевозможных типов, реализующих некоторый типаж (trait);
> - либо набор всевозможных типов, получаемых подстановкой параметров в обобщённый тип.

С такой поправкой у нас, безусловно, всё ещё остаётся пространство для манёвра - я, например, не исключаю, что под это определение подпадает даже банальный `Vec<T>`, но для дальнейшего изучения оно нам вполне подойдёт.

- - - - - - - - - - - - - -

Как я уже упомянул в самом начале, источником вдохновения для всей этой работы послужили возможности Idris, продемонстрированные на простом примере. По аналогии с этим примером я декларирую цель нынешней работы:
> реализовать квазизависимый тип массива фиксированной длины (вектора) `Vect<N, T>`, инвариант которого - неизменная длина при неизменном значении параметра `N`.

## Первая попытка: ложный след

Изначально, впрочем, идея была несколько иной и заключалась в следующем.

Во-первых, квазизависимый тип должен быть простой обёрткой над обычным типом (или несколькими типами). В случае вектора это означает очень простое определение:
```rust
pub struct Vect<Item>(Vec<Item>);
```
Обратите внимание, что внутреннее поле структуры объявлено приватным - ни у кого извне права напрямую что-то сделать с этим стандартным вектором нет, даже если у них есть изменяемая ссылка на `Vect`. 

### Полезная часть

Что, всё-таки, удалось извлечь из этой первой реализации?

Во-первых, это идея "замороженного типа", которая в итоге, после всех упрощений и корректировок, преобразовалась в описанный ниже типаж Dependent.

Во-вторых, это, разумеется, первая тестовая функция - та самая zip_add, которая компилируется только тогда, когда ей переданы два вектора гарантированно одинаковой длины. Она также была неоднократно переработана в процессе дальнейшей разработки, но сама идея осталась прежней.

## Вторая попытка: шаги реализации

### `qd_core`: типаж Dependent

Как вообще можно гарантировать поддержание инварианта? Безусловно, самый простой вариант - просто сделать искомый тип неизменяемым, но 

// Dependent
И если бы [вот это](https://github.com/rust-lang/rust/issues/8995) было реализовано, возможно, я бы и вовсе обошёлся без типажа.