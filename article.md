Системы типов - это настоящее безумие.

<!-- ![КДПВ в подражание XKCD](https://habrastorage.org/webt/y0/cp/de/y0cpdecpzjvzezlr09zet6hvtfw.png) -->

Некоторое время назад я уже отметился здесь со статьёй, в которой пытался разобрать, какие гарантии в compile-time может дать система типов Rust. Кое-какие интересные моменты удалось выловить уже тогда, однако больше всего меня зацепил весьма развёрнутый [комментарий](https://habr.com/ru/post/468145/#comment_20652891), описывающий некоторые вещи, доступные в зависимо-типизированном Idris.
Разумеется, я не мог остаться в стороне. Результат исследований доступен [на github](https://github.com/Cerberuser/quazidependent_types), а детальный разбор - под катом.

<cut/>

Сразу должен оговориться: само собой, *настоящие* зависимые типы в Rust, скорее всего, не реализуемы. Однако мы можем определить *псевдозависимые*, или *квазизависимые* (отсюда и название репозитория) типы, например, следующим образом:

> Пусть у нас имеется некоторое *семейство* типов, состоящее из отдельных типов, далее - *тип-экземпляр*. Назовём это семейство **квазизависимым типом**, если для каждого типа-экземпляра при использовании в безопасном коде гарантируется поддержание некоторого инварианта, полностью определяемого конкретным типом-экземпляром.

Заметим, что формально под это определение подходит достаточно большое количество уже существующих типов - так, если мы рассмотрим "семейство", состоящее из одного типа `str`, мы формально можем сказать, что это семейство является квазизависимым типом - ведь тип `str` гарантирует, что его содержимое - валидный UTF-8. Но такие случаи нам, очевидно, не интересны, поэтому мы немного уточним определение:

> **Семейством типов** назовём одно из двух:
> - либо набор всевозможных типов, реализующих некоторый типаж (trait);
> - либо набор всевозможных типов, получаемых подстановкой параметров в обобщённый тип.

С такой поправкой у нас, безусловно, всё ещё остаётся пространство для манёвра - я, например, не исключаю, что под это определение с определённой точки зрения подпадает даже банальный `Vec<T>`, но для дальнейшего изучения оно нам вполне подойдёт.

- - - - - - - - - - - - - -

Как я уже упомянул в самом начале, источником вдохновения для всей этой работы послужили возможности Idris, продемонстрированные на простом примере. По аналогии с этим примером я декларирую цель нынешней работы:
> реализовать квазизависимый тип массива фиксированной длины (вектора) `Vect<N, T>`, инвариант которого - неизменная длина при неизменном значении параметра `N`.

## Первая попытка: ложный след

Изначально, впрочем, идея была несколько иной и заключалась в следующем.

Первое и основное: в качестве искомого семейства типов мы выберем семейство т.н. "непрозрачных" типов, удовлетворяющих некоторому типажу. Иначе говоря, единственным способом создать значение искомого квазизависимого типа должен быть возврат его из функции, возвращающей `impl Trait`. Однако, прежде чем мы перейдём к собственно типажу, нужно сделать несколько промежуточных шагов.

Во-первых, предположил я, квазизависимый тип должен быть простой обёрткой над обычным типом (или несколькими типами). В случае вектора это означает очень простое определение:
```rust
pub struct Vect<Item>(Vec<Item>);
```
Обратите внимание, что внутреннее поле структуры объявлено приватным - ни у кого извне права напрямую что-то сделать с этим стандартным вектором нет, даже если у них есть изменяемая ссылка на `Vect`.

Во-вторых, неизменяемый тип - это, конечно, хорошо, но какая-то возможность заглянуть внутрь у нас всё-таки должна быть (только так, чтобы не сломать инвариант). В этом месте я задумался о том, что неплохо было бы заранее заготовить возможность расширения, и написал следующее:
```rust
// Этому типажу обязаны удовлетворять все типы, которые мы размещаем внутри
// наших квазизависимых типов.
// А именно:
pub trait DependentInner: Sized {
    // должна существовать "замороженная" версия этого типа, которая
    // не позволяет сломать искомый инвариант;
    type Frozen: ?Sized;
    // должна быть возможность из уникальной ссылки на сам тип получить
    // уникальную ссылку на "замороженную" версию;
    fn freeze(&mut self) -> &mut Self::Frozen;
    // и должна быть возможность воссоздать тип из "замороженной" версии.
    fn recreate(_: &Self::Frozen) -> Self;
}

// А ещё для каждого такого типа мы автоматически реализуем два действия:
pub trait DependentInnerOperate: DependentInner {
    // трансформацию, т.е. генерацию нового объекта как изменённого старого,
    fn transform(mut self, f: impl FnOnce(&mut Self::Frozen)) -> Self {
        let mut tmp = Self::recreate(self.freeze());
        f(tmp.freeze());
        tmp
    }
    // и изменение in-place.
    fn operate(&mut self, f: impl FnOnce(&mut Self::Frozen)) {
        f(self.freeze());
    }
}
impl<T: DependentInner> DependentInnerOperate for T {}
```

Думаю, достаточно очевидно, как они реализуются для стандартного вектора - он тривиально преобразуется в срез, длина которого гарантированно неизменна, что нам, собственно, и требуется:
```rust
impl<Item: Clone> DependentInner for Vec<Item> {
    type Frozen = [Item];
    fn freeze(&mut self) -> &mut Self::Frozen {
        self.as_mut_slice()
    }
    fn recreate(frozen: &Self::Frozen) -> Self {
        frozen.iter().cloned().collect()
    }
}
```

В-третьих - и вот теперь мы переходим к, собственно, реализации квазизависимости. Пока что, по очевидным причинам, её у нас нет, поскольку нет того самого семейства типов, а есть один тип, который при этом может хранить в себе абсолютно любой вектор, безо всякого учёта обещанных инвариантов.

Как мы и обещали, нам требуется создать типаж, который будет реализовывать наш `Vect<T>`. Окей, действуем:
```rust
pub trait DependentVec<Inner: DependentInnerOperate>: Sized {
    // тут определения методов
}
impl<Item: Clone> DependentVec<Vec<Item>> for Vect<Item> {
    // тут их реализация
}
```

В-четвёртых, вспомним одну из основных фич реальных зависимых типов: инварианты, поддерживаемые ими, могут быть различными для разных вызовов одной и той же функции. В случае с квазизависимыми типами это означает, что каждый вызов функции должен возвращать разные типы, что напрямую в Rust невозможно. Однако мы можем с помощью макроса сгенерировать для каждого места вызова примерно такой код:
```rust
{
    fn local<Item>() -> impl DependentVec<Vec<Item>> {
        // тут тело исходной функции
    }
    local()
}
```
Это одно из важных свойств `impl Trait`: даже если реально возвращаемый тип в разных случаях один и тот же, каждая такая функция будет рассматриваться как возвращающая уникальный анонимный тип. Теперь, чтобы сделать с этими типами что-то полезное, нам надо реализовать метод на `Vect<T>` и на соответствующем типаже:
```rust
impl<Item: Clone> DependentVec<Vec<Item>> for Vect<Item> {
    fn try_unify<T: DependentVec<Vec<Item>>>(self, other: T) -> Result<(Self, Self), (Self, T)> {
        if self.len() == other.len() {
            let other = Self(other.into_inner());
            Ok((self, other))
        } else {
            Err((self, other))
        }
    }
}
```
Таким образом, если `try_unify` вернула `Ok`, мы знаем - и, главное, знает компилятор! - что два значения внутри `Ok` на самом деле одного и того же типа.

Ну и, наконец, напишем простенькую тестовую функцию:
```rust
pub fn zip_add<Item, T>(first: &T, second: &T) -> T
where
    Item: AddAssign<Item> + Clone,
    T: DependentVec<Vec<Item>> {
    first.map_ref(|v1| 
        second.consume_ref(|v2| 
            v1.iter_mut()
                .zip(v2.iter())
                .for_each(|(i1, i2)| *i1 += i2.clone())
        )
    )
}
```
Где функции `map_ref` и `consume_ref` определены, соответственно, так:
```rust
impl<Item: Clone> DependentVec<Vec<Item>> for Vect<Item> {
    fn inner(&self) -> &Vec<Item> {
        &self.0
    }
    fn map_ref(&self, f: impl FnOnce(&mut <Vec<Item> as DependentInner>::Frozen)) -> Self {
        let mut inner = self.inner().clone();
        f(inner.freeze());
        Self(inner)
    }
    fn consume_ref(&self, f: impl FnOnce(&mut <Vec<Item> as DependentInner>::Frozen)) {
        f(self.inner().clone().freeze())
    }
}
```
(Названия объясняются тем, что в ходе работы также имелись функции `map` и `consume`, принимающие `self`)

Не стану скрывать, конструкция получилась весьма громоздкая, к тому же сильно отталкивала необходимость дублировать описания функций и в типаже, и в реализации - привет, Си, привет, файлы заголовков, давно не виделись!

В попытках как-то отладить логику я написал парочку тестов, начал писать макрос, который бы сгенерировал типаж автоматически по описанию самой структуры, но быстро понял: подобный подход меня заводит куда-то совсем не туда, куда следовало бы.

### Полезная часть

Что, всё-таки, удалось извлечь из этой первой реализации?

Во-первых, это идея "замороженного типа", которая в итоге, после всех упрощений и корректировок, преобразовалась в описанный ниже типаж Dependent.

Во-вторых, это, разумеется, первая тестовая функция - та самая zip_add, которая компилируется только тогда, когда ей переданы два вектора гарантированно одинаковой длины. Она также была неоднократно переработана в процессе дальнейшей разработки, но сама идея осталась прежней.

## Вторая попытка: шаги реализации

Сразу выделим три ключевых изменения, которые было решено внести при переработке.

Во-первых, как уже было сказано выше, семейство типов `Vect` на самом деле должно иметь не один, а два параметра, один из которых, как и ранее, характеризует содержание вектора, другой - отвечает за длину. Как будет показано ниже, такой тип можно просто вернуть из обобщённой функции, не генерируя в явном виде множество её копий, а вместо этого меняя только собственно обобщённый параметр; как следствие, макрос (который при таком подходе тоже необходим) можно сделать существенно более простым.

Во-вторых, для описания длины вектора - а, на самом деле, для описания любых натуральных чисел, - мы вводим новый типаж `Nat`, которому можем заранее прописать все необходимые свойства. 

В-третьих, вместо того, чтобы требовать точного совпадения типов векторов, мы будем передавать в функцию *доказательство* того, что их длины равны - иначе говоря, объект с таким типом, который можно сконструировать только в случае, когда длины действительно равны.

### `qd_core`: типаж Dependent

Кроме того, одним из первых изменений была попытка описать поведение квазизависимоого типа в более или менее общем виде. А именно, обратил внимание, что реализованный ранее типаж `DependentVect` на самом деле не использует ни одной детали, специфичной именно для вектора, за исключением "внутреннего" типа. А значит, мы можем переписать его в таком виде:
```rust
pub trait Dependent {
    type Inner: DependentInnerOperate;
    fn from_inner(_: Self::Inner) -> Self
    where
        Self: Sized;
    fn into_inner(self) -> Self::Inner;
    fn inner(&self) -> &Self::Inner;
}
pub trait DependentOperate: Dependent {
    // здесь содержатся реализации методов map, consume и т.д.
    // в терминах from_inner/into_inner/inner
}
impl<T: Dependent> DependentOperate for T {}
```
Вскоре, однако, стало ясно, что наличие нескольких отдельных типажей только создаёт дополнительные сложности, никак при этом не упрощая нам жизнь. Мы можем избавиться от них, переместив тип `Frozen` непосредственно в типаж `Dependent` и устранив автоматически реализованные методы:
```rust
pub trait Dependent {
    type Native;
    type Frozen: ?Sized;
    fn freeze(&self) -> &Self::Frozen;
    fn freeze_mut(&mut self) -> &mut Self::Frozen;
    fn into_native(self) -> Self::Native;
    fn as_native(&self) -> &Self::Native;
}
```

На этом этапе может возникнуть вопрос, а зачем нам, собственно, этот типаж? Я на это отвечу так: технически, да, на этом этапе уже перестал быть нужен. Я сохранил его в коде в основном в качестве своеобразной документации - описания того, что мы ждём от любого квазизависимого типа. Теоретически, мы могли бы написать какие-нибудь методы, способные принимать любой квазизависимый тип и совершать с ним некоторые операции, аналогично монадическим конструкциям, но на нынешнем этапе единственный содержательный элемент этого типажа - явно задекларированные типы `Native` и `Frozen`, которые, [если бы Rust это позволил](https://github.com/rust-lang/rust/issues/8995), спокойно могли бы быть добавлены непосредственно на тип.

### `qd_nat`: длина вектора

Теперь вернёмся к основным построениям. Как уже было сказано выше, для дальнейшей работы над вектором нам нужно иметь на руках какую-то конструкцию, позволяющую обозначить некоторое произвольное (но фиксированное на всём протяжении программы) натуральное число заданным символом.

Недолго думая, создадим для этого новый типаж:
```rust
pub trait Nat: Sized {
    fn as_usize(&self) -> usize;
    fn from_usize(s: usize) -> Self;
}
```
И добавим возможность получить доказательство того, что два объекта с этим типажом равны:
```rust
use std::marker::PhantomData;
#[derive(Copy, Clone, Debug)]
pub struct Equiv<T1: Nat, T2: Nat>(PhantomData<(T1, T2)>);
impl<T1: Nat, T2: Nat> Equiv<T1, T2> {
    pub fn rev(self) -> Equiv<T2, T1> {
        Equiv(PhantomData)
    }
}

pub trait NatEq: Nat {
    fn eq<N: Nat>(this: Self, other: N) -> Option<Equiv<Self, N>> {
        if this.as_usize() == other.as_usize() {
            Some(Equiv(PhantomData))
        } else {
            None
        }
    }
}
impl<T: Nat> NatEq for T {}
```

### `qd_vect`: собственно вектор

Теперь мы можем попробовать переписать наш квазизависимый вектор, используя параметр типа для длины:
```rust
pub struct Vect<T, N: Nat>(Vec<T>, PhantomData<N>);
impl<Item: Clone, N: Nat> Dependent for Vect<Item, N> {
    type Native = Vec<Item>;
    type Frozen = [Item];
    fn freeze(&self) -> &Self::Frozen {
        self.0.as_slice()
    }
    fn freeze_mut(&mut self) -> &mut Self::Frozen {
        self.0.as_mut_slice()
    }
    fn into_native(self) -> Self::Native {
        self.0
    }
    fn as_native(&self) -> &Self::Native {
        &self.0
    }
}
```
Оба поля в полученной структуре приватные, следовательно, создать её вне текущего модуля пока что невозможно. Предоставим такую возможность:
```rust
pub fn collect<Item: Clone, N: Nat, I: IntoIterator<Item = Item>>(iter: I) -> (N, Vect<Item, N>) {
    let inner: Vec<_> = iter.into_iter().collect();
    (N::from_usize(inner.len()), Vect(inner, PhantomData))
}
```
Как видим, эта функция, помимо самого вектора, возвращает ещё и некоторый объект с типажом `Nat`, описывающий его длину.

Попробуем протестировать полученную конструкцию, для этого воспользуемся уже знакомой функцией `zip_sum`, переписав её под новый интерфейс:
```rust
fn zip_sum<T: Clone + Add<T, Output = T>, N: Nat>(
    first: Vect<T, N>,
    second: Vect<T, N>,
) -> Vect<T, N> {
    let mut v1 = first.clone();
    let v2 = second.freeze();
    v1.freeze_mut().iter_mut()
        .zip(v2.iter())
        .for_each(|(i1, i2)| *i1 = i1.clone() + i2.clone())
    v1
}
```
Теперь, соответственно, перед нами встаёт вопрос, как нам получить объект `Vect` - а точнее, как вызвать определённую выше функцию `collect`, поскольку попытка это сделать "в лоб" приведёт к ошибке вроде такой:
```text

```