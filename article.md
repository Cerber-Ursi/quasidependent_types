Системы типов - это настоящее безумие.

<!-- ![КДПВ в подражание XKCD](https://habrastorage.org/webt/y0/cp/de/y0cpdecpzjvzezlr09zet6hvtfw.png) -->

Некоторое время назад я уже отметился здесь со статьёй, в которой пытался разобрать, какие гарантии в compile-time может дать система типов Rust. Кое-какие интересные моменты удалось выловить уже тогда, однако больше всего меня зацепил весьма развёрнутый [комментарий](https://habr.com/ru/post/468145/#comment_20652891), описывающий некоторые вещи, доступные в зависимо-типизированном Idris.
Разумеется, я не мог остаться в стороне. Результат исследований доступен [на github](https://github.com/Cerberuser/quazidependent_types), а детальный разбор - под катом.

<cut/>

Сразу должен оговориться: само собой, *настоящие* зависимые типы в Rust, скорее всего, не реализуемы. Однако мы можем определить *псевдозависимые*, или *квазизависимые* (отсюда и название репозитория) типы, например, следующим образом:

> Пусть у нас имеется некоторое *семейство* типов, состоящее из отдельных типов, далее - *тип-экземпляр*. Назовём это семейство **квазизависимым типом**, если для каждого типа-экземпляра при использовании в безопасном коде гарантируется поддержание некоторого инварианта, полностью определяемого конкретным типом-экземпляром.

Заметим, что формально под это определение подходит достаточно большое количество уже существующих типов - так, если мы рассмотрим "семейство", состоящее из одного типа `str`, мы формально можем сказать, что это семейство является квазизависимым типом - ведь тип `str` гарантирует, что его содержимое - валидный UTF-8. Но такие случаи нам, очевидно, не интересны, поэтому мы немного уточним определение:

> **Семейством типов** назовём одно из двух:
> - либо набор всевозможных типов, реализующих некоторый типаж (trait);
> - либо набор всевозможных типов, получаемых подстановкой параметров в обобщённый тип.

С такой поправкой у нас, безусловно, всё ещё остаётся пространство для манёвра - я, например, не исключаю, что под это определение с определённой точки зрения подпадает даже банальный `Vec<T>`, но для дальнейшего изучения оно нам вполне подойдёт.

- - - - - - - - - - - - - -

Как я уже упомянул в самом начале, источником вдохновения для всей этой работы послужили возможности Idris, продемонстрированные на простом примере. По аналогии с этим примером я декларирую цель нынешней работы:
> реализовать квазизависимый тип массива фиксированной длины (вектора) `Vect<N, T>`, инвариант которого - неизменная длина при неизменном значении параметра `N`.

## Первая попытка: ложный след

Изначально, впрочем, идея была несколько иной и заключалась в следующем.

Первое и основное: в качестве искомого семейства типов мы выберем семейство т.н. "непрозрачных" типов, удовлетворяющих некоторому типажу. Иначе говоря, единственным способом создать значение искомого квазизависимого типа должен быть возврат его из функции, возвращающей `impl Trait`. Однако, прежде чем мы перейдём к собственно типажу, нужно сделать несколько промежуточных шагов.

Во-первых, предположил я, квазизависимый тип должен быть простой обёрткой над обычным типом (или несколькими типами). В случае вектора это означает очень простое определение:
```rust
pub struct Vect<Item>(Vec<Item>);
```
Обратите внимание, что внутреннее поле структуры объявлено приватным - ни у кого извне права напрямую что-то сделать с этим стандартным вектором нет, даже если у них есть изменяемая ссылка на `Vect`.

Во-вторых, неизменяемый тип - это, конечно, хорошо, но какая-то возможность заглянуть внутрь у нас всё-таки должна быть (только так, чтобы не сломать инвариант). В этом месте я задумался о том, что неплохо было бы заранее заготовить возможность расширения, и написал следующее:
```rust
// Этому типажу обязаны удовлетворять все типы, которые мы размещаем внутри
// наших квазизависимых типов.
// А именно:
pub trait DependentInner: Sized {
    // должна существовать "замороженная" версия этого типа, которая
    // не позволяет сломать искомый инвариант;
    type Frozen: ?Sized;
    // должна быть возможность из уникальной ссылки на сам тип получить
    // уникальную ссылку на "замороженную" версию;
    fn freeze(&mut self) -> &mut Self::Frozen;
    // и должна быть возможность воссоздать тип из "замороженной" версии.
    fn recreate(_: &Self::Frozen) -> Self;
}

// А ещё для каждого такого типа мы автоматически реализуем два действия:
pub trait DependentInnerOperate: DependentInner {
    // трансформацию, т.е. генерацию нового объекта как изменённого старого,
    fn transform(mut self, f: impl FnOnce(&mut Self::Frozen)) -> Self {
        let mut tmp = Self::recreate(self.freeze());
        f(tmp.freeze());
        tmp
    }
    // и изменение in-place.
    fn operate(&mut self, f: impl FnOnce(&mut Self::Frozen)) {
        f(self.freeze());
    }
}
impl<T: DependentInner> DependentInnerOperate for T {}
```

Думаю, достаточно очевидно, как они реализуются для стандартного вектора - он тривиально преобразуется в срез, длина которого гарантированно неизменна, что нам, собственно, и требуется:
```rust
impl<Item: Clone> DependentInner for Vec<Item> {
    type Frozen = [Item];
    fn freeze(&mut self) -> &mut Self::Frozen {
        self.as_mut_slice()
    }
    fn recreate(frozen: &Self::Frozen) -> Self {
        frozen.iter().cloned().collect()
    }
}
```

В-третьих - и вот теперь мы переходим к, собственно, реализации квазизависимости. Пока что, по очевидным причинам, её у нас нет, поскольку нет того самого семейства типов, а есть один тип, который при этом может хранить в себе абсолютно любой вектор, безо всякого учёта обещанных инвариантов.

Как мы и обещали, нам требуется создать типаж, который будет реализовывать наш `Vect<T>`. Окей, действуем:
```rust
pub trait DependentVec<Inner: DependentInnerOperate>: Sized {
    // тут определения методов
}
impl<Item: Clone> DependentVec<Vec<Item>> for Vect<Item> {
    // тут их реализация
}
```

В-четвёртых, вспомним одну из основных фич реальных зависимых типов: инварианты, поддерживаемые ими, могут быть различными для разных вызовов одной и той же функции. В случае с квазизависимыми типами это означает, что каждый вызов функции должен возвращать разные типы, что напрямую в Rust невозможно. Однако мы можем с помощью макроса сгенерировать для каждого места вызова примерно такой код:
```rust
{
    fn local<Item>() -> impl DependentVec<Vec<Item>> {
        // тут тело исходной функции
    }
    local()
}
```
Это одно из важных свойств `impl Trait`: даже если реально возвращаемый тип в разных случаях один и тот же, каждая такая функция будет рассматриваться как возвращающая уникальный анонимный тип. Теперь, чтобы сделать с этими типами что-то полезное, нам надо реализовать метод на `Vect<T>` и на соответствующем типаже:
```rust
impl<Item: Clone> DependentVec<Vec<Item>> for Vect<Item> {
    fn try_unify<T: DependentVec<Vec<Item>>>(self, other: T) -> Result<(Self, Self), (Self, T)> {
        if self.len() == other.len() {
            let other = Self(other.into_inner());
            Ok((self, other))
        } else {
            Err((self, other))
        }
    }
}
```
Таким образом, если `try_unify` вернула `Ok`, мы знаем - и, главное, знает компилятор! - что два значения внутри `Ok` на самом деле одного и того же типа.

Ну и, наконец, напишем простенькую тестовую функцию:
```rust
pub fn zip_add<Item, T>(first: &T, second: &T) -> T
where
    Item: AddAssign<Item> + Clone,
    T: DependentVec<Vec<Item>> {
    first.map_ref(|v1| 
        second.consume_ref(|v2| 
            v1.iter_mut()
                .zip(v2.iter())
                .for_each(|(i1, i2)| *i1 += i2.clone())
        )
    )
}
```
Где функции `map_ref` и `consume_ref` определены, соответственно, так:
```rust
impl<Item: Clone> DependentVec<Vec<Item>> for Vect<Item> {
    fn inner(&self) -> &Vec<Item> {
        &self.0
    }
    fn map_ref(&self, f: impl FnOnce(&mut <Vec<Item> as DependentInner>::Frozen)) -> Self {
        let mut inner = self.inner().clone();
        f(inner.freeze());
        Self(inner)
    }
    fn consume_ref(&self, f: impl FnOnce(&mut <Vec<Item> as DependentInner>::Frozen)) {
        f(self.inner().clone().freeze())
    }
}
```
(Названия объясняются тем, что в ходе работы также имелись функции `map` и `consume`, принимающие `self`)

Не стану скрывать, конструкция получилась весьма громоздкая, к тому же сильно отталкивала необходимость дублировать описания функций и в типаже, и в реализации - привет, Си, привет, файлы заголовков, давно не виделись!

В попытках как-то отладить логику я написал парочку тестов, начал писать макрос, который бы сгенерировал типаж автоматически по описанию самой структуры, но быстро понял: подобный подход меня заводит куда-то совсем не туда, куда следовало бы.

### Полезная часть

Что, всё-таки, удалось извлечь из этой первой реализации?

Во-первых, это идея "замороженного типа", которая в итоге, после всех упрощений и корректировок, преобразовалась в описанный ниже типаж Dependent.

Во-вторых, это, разумеется, первая тестовая функция - та самая zip_add, которая компилируется только тогда, когда ей переданы два вектора гарантированно одинаковой длины. Она также была неоднократно переработана в процессе дальнейшей разработки, но сама идея осталась прежней.

## Вторая попытка: шаги реализации

Сразу выделим три ключевых изменения, которые было решено внести при переработке.

Во-первых, как уже было сказано выше, семейство типов `Vect` на самом деле должно иметь не один, а два параметра, один из которых, как и ранее, характеризует содержание вектора, другой - отвечает за длину. Как будет показано ниже, такой тип можно просто вернуть из обобщённой функции, не генерируя в явном виде множество её копий, а вместо этого меняя только собственно обобщённый параметр; как следствие, макрос (который при таком подходе тоже необходим) можно сделать существенно более простым.

Во-вторых, для описания длины вектора - а, на самом деле, для описания любых натуральных чисел, - мы вводим новый типаж `Nat`, которому можем заранее прописать все необходимые свойства. 

В-третьих, вместо того, чтобы требовать точного совпадения типов векторов, мы будем передавать в функцию *доказательство* того, что их длины равны - иначе говоря, объект с таким типом, который можно сконструировать только в случае, когда длины действительно равны.

### `qd_core`: типаж Dependent

Кроме того, одним из первых изменений была попытка описать поведение квазизависимоого типа в более или менее общем виде. А именно, обратил внимание, что реализованный ранее типаж `DependentVect` на самом деле не использует ни одной детали, специфичной именно для вектора, за исключением "внутреннего" типа. А значит, мы можем переписать его в таком виде:
```rust
pub trait Dependent {
    type Inner: DependentInnerOperate;
    fn from_inner(_: Self::Inner) -> Self
    where
        Self: Sized;
    fn into_inner(self) -> Self::Inner;
    fn inner(&self) -> &Self::Inner;
}
pub trait DependentOperate: Dependent {
    // здесь содержатся реализации методов map, consume и т.д.
    // в терминах from_inner/into_inner/inner
}
impl<T: Dependent> DependentOperate for T {}
```
Вскоре, однако, стало ясно, что наличие нескольких отдельных типажей только создаёт дополнительные сложности, никак при этом не упрощая нам жизнь. Мы можем избавиться от них, переместив тип `Frozen` непосредственно в типаж `Dependent` и устранив автоматически реализованные методы:
```rust
pub trait Dependent {
    type Native;
    type Frozen: ?Sized;
    fn freeze(&self) -> &Self::Frozen;
    fn freeze_mut(&mut self) -> &mut Self::Frozen;
    fn into_native(self) -> Self::Native;
    fn as_native(&self) -> &Self::Native;
}
```

На этом этапе может возникнуть вопрос, а зачем нам, собственно, этот типаж? Я на это отвечу так: технически, да, на этом этапе уже перестал быть нужен. Я сохранил его в коде в основном в качестве своеобразной документации - описания того, что мы ждём от любого квазизависимого типа. Теоретически, мы могли бы написать какие-нибудь методы, способные принимать любой квазизависимый тип и совершать с ним некоторые операции, аналогично монадическим конструкциям, но на нынешнем этапе единственный содержательный элемент этого типажа - явно задекларированные типы `Native` и `Frozen`, которые, [если бы Rust это позволил](https://github.com/rust-lang/rust/issues/8995), спокойно могли бы быть добавлены непосредственно на тип.

### `qd_nat`: длина вектора

Теперь вернёмся к основным построениям. Как уже было сказано выше, для дальнейшей работы над вектором нам нужно иметь на руках какую-то конструкцию, позволяющую обозначить некоторое произвольное (но фиксированное на всём протяжении программы) натуральное число заданным символом.

Недолго думая, создадим для этого новый типаж:
```rust
pub trait Nat: Sized {
    fn as_usize(&self) -> usize;
    fn from_usize(s: usize) -> Self;
}
```
И добавим возможность получить доказательство того, что два объекта с этим типажом равны:
```rust
use std::marker::PhantomData;

#[derive(Copy, Clone, Debug)]
pub struct Equiv<T1: Nat, T2: Nat>(PhantomData<(T1, T2)>);

impl<T1: Nat, T2: Nat> Equiv<T1, T2> {
    pub fn rev(self) -> Equiv<T2, T1> {
        Equiv(PhantomData)
    }
}

pub trait NatEq: Nat {
    fn eq<N: Nat>(this: Self, other: N) -> Option<Equiv<Self, N>> {
        if this.as_usize() == other.as_usize() {
            Some(Equiv(PhantomData))
        } else {
            None
        }
    }
}
impl<T: Nat> NatEq for T {}
```

### `qd_vect`: собственно вектор

Теперь мы можем попробовать переписать наш квазизависимый вектор, используя параметр типа для длины:
```rust
pub struct Vect<T, N: Nat>(Vec<T>, PhantomData<N>);
impl<Item: Clone, N: Nat> Dependent for Vect<Item, N> {
    type Native = Vec<Item>;
    type Frozen = [Item];
    fn freeze(&self) -> &Self::Frozen {
        self.0.as_slice()
    }
    fn freeze_mut(&mut self) -> &mut Self::Frozen {
        self.0.as_mut_slice()
    }
    fn into_native(self) -> Self::Native {
        self.0
    }
    fn as_native(&self) -> &Self::Native {
        &self.0
    }
}
```
Оба поля в полученной структуре приватные, следовательно, создать её вне текущего модуля пока что невозможно. Предоставим такую возможность:
```rust
pub fn collect<Item: Clone, N: Nat, I: IntoIterator<Item = Item>>(iter: I) -> (N, Vect<Item, N>) {
    let inner: Vec<_> = iter.into_iter().collect();
    (N::from_usize(inner.len()), Vect(inner, PhantomData))
}
```
Как видим, эта функция, помимо самого вектора, возвращает ещё и некоторый объект с типажом `Nat`, описывающий его длину.

Попробуем протестировать полученную конструкцию, для этого воспользуемся уже знакомой функцией `zip_sum`, переписав её под новый интерфейс:
```rust
fn zip_sum<T: Clone + Add<T, Output = T>, N: Nat>(
    first: Vect<T, N>,
    second: Vect<T, N>,
) -> Vect<T, N> {
    let mut v1 = first.clone();
    let v2 = second.freeze();
    v1.freeze_mut().iter_mut()
        .zip(v2.iter())
        .for_each(|(i1, i2)| *i1 = i1.clone() + i2.clone())
    v1
}
```
Теперь, соответственно, перед нами встаёт вопрос, как нам получить объект `Vect` - а точнее, как вызвать определённую выше функцию `collect`, поскольку попытка это сделать "в лоб" приведёт к ошибке вроде такой:
```text
error[E0283]: type annotations needed for `(N, Vect<u32, N>)`
  --> ${MODULE}/tests/test.rs:7:13
   |
7  |     let _ = collect(vec![1u32]);
   |         -   ^^^^^^^ cannot infer type for type parameter `N` declared on the function `collect`
   |         |
   |         consider giving this pattern the explicit type `(N, Vect<u32, N>)`, where the type parameter `N` is specified
   | 
  ::: ${MODULE}/src/lib.rs:28:32
   |
28 | pub fn collect<Item: Clone, N: Nat, I: IntoIterator<Item = Item>>(iter: I) -> (N, Vect<Item, N>) {
   |                                --- required by this bound in `collect`
   |
   = note: cannot satisfy `_: Nat`
help: consider specifying the type arguments in the function call
   |
7  |     let _ = collect::<Item, N, I>(vec![1u32]);
   |                    ^^^^^^^^^^^^^^
```
Первый - и кажущийся очевидным - вариант состоит в том, чтобы просто сгенерировать новый тип непосредственно перед вызовом функции, а затем передать его в качестве обобщённого параметра:
```rust
{
    #[derive(Copy, Clone)]
    struct N(usize);
    impl Nat for N {
        fn as_usize(&self) -> usize {
            self.0
        }
        fn from_usize(s: usize) -> Self {
            Self(s)
        }
    }
    collect::<_, $n, _>($v)
}
```
Однако с таким подходом возникает достаточно очевидная проблема: у нас нет никакого способа поддержать инвариант для типа `N`. Нет никаких гарантий, что кто-то не попытается определить этот тип, а затем вызвать `N::from_usize` с двумя разными аргументами.

### `qd_timestamp_marker`: де-факто приватный типаж

Выход из этой ситуации простой: типаж `Nat` должен быть реализован строго подконтрольным образом. Каким именно образом - мы опишем чуть ниже, а здесь разговор пойдёт о том, как добиться этой самой подконтрольности. Строго говоря - никак, но есть один относительно простой трюк, о сути которого можно догадаться из названия модуля.

Допустим, мы подготовили реализацию нашего типажа `Nat` и предоставили возможность сгенерировать эту реализацию для нового типа через некоторый макрос:
```rust
#[macro_export]
macro_rules! n {
    () => {
        #[derive(Copy, Clone)]
        struct N(usize);
        impl $crate::Nat for N {
            // реализация
        }
    };
}
```
Вопрос: что может помешать пользователю написать ровно тот же самый код от руки? В процессе работы над этим проектом я задал этот вопрос на форуме Rust (применительно к первому варианту реализации, но это не сильно что-то изменило), и получил на него в числе прочего [такой вот ответ](https://users.rust-lang.org/t/creating-code-to-be-run-through-macro-but-not-directly/33984/5), сводящийся к достаточно простой идее: написать процедурный макрос, который некоторым случайным (или не случайным, но и не постоянным) образом поменяет как определение типажа, так и реализующий его макрос. В этом случае реализовать типаж вручную будет невозможно - его имя будет генерироваться заново при каждой компиляции пакета.

Что ж, пишем:

<spoiler title="Полный код процедурного макроса">

```rust
extern crate proc_macro;

use proc_macro::TokenStream;
use quote::{format_ident, quote, ToTokens};
use std::time::{SystemTime, UNIX_EPOCH};
use syn::*;

#[proc_macro_attribute]
pub fn timestamp_marker(attr: TokenStream, input: TokenStream) -> TokenStream {
    // Макрос будет преобразовывать модуль целиком, со всем содержимым
    let mut input = parse_macro_input!(input as ItemMod);

    // Идентификатор, который мы будем заменять, передадим как параметр
    let replaced = parse_macro_input!(attr as Ident);
    // А в качестве замены возьмём его же, но с приделанным текущим timestamp-ом
    let replacement = format_ident!(
        "{}{}",
        replaced,
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .expect("Time went backwards")
            .as_millis()
    );

    // Извлекаем содержимое модуля
    let content = input
        .content
        .as_mut()
        // Если его нет (т.е. модуль в отдельном файле) - паникуем, получим ошибку компиляции
        .expect("Only the inline modules can be labeled with timestamp");
    // И прогоняем каждый элемент через функцию замены (см. ниже)
    content.1.iter_mut().for_each(|item| {
        *item = parse2(update(item.to_token_stream(), &replaced, &replacement)).unwrap()
    });

    let output = quote! { #input };
    output.into()
}

fn update(item: proc_macro2::TokenStream, from: &Ident, to: &Ident) -> proc_macro2::TokenStream {
    use proc_macro2::*;
    item.into_iter()
        // Нас здесь интересует два основных варианта:
        // либо перед нами группа (т.е. нечто в скобках),
        // либо перед нами идентификатор.
        .map(|tok| match tok {
            TokenTree::Group(group) => {
                // Группу мы обрабатываем рекурсивно,
                let mut new_group = Group::new(group.delimiter(), update(group.stream(), from, to));
                // не забывая указать новой группе корректное местоположение
                new_group.set_span(group.span());
                TokenTree::Group(new_group)
            }
            TokenTree::Ident(ident) if &ident == from => {
                // Идентификатор мы меняем, только если он совпадает с заменяемым.
                let mut to = to.clone();
                // И, опять же, не забываем про местоположение.
                to.set_span(ident.span());
                TokenTree::Ident(to)
            }
            // Всё прочее оставляем как есть.
            tok => tok,
        })
        .collect()
}
```
</spoiler>

### `qd_nat`: квазизависимые числа

Так как типаж `Nat` используется во внешнем коде, непосредственно его пометить мы не можем. Обходится проблема очень просто:
```rust
#[timestamp_marker(NatInner)]
pub mod nat {
    pub trait NatInner {}
    pub trait Nat: Sized + NatInner + Clone + Copy {
        fn as_usize(&self) -> usize;
        fn from_usize(s: usize) -> Self;
    }
}
```
Реализовать типаж `Nat` по-прежнему можно где угодно, и мы этим воспользуемся. А вот типаж `NatInner` - уже нет, и, следовательно, все реализации типажа `Nat` становятся нам подконтрольны.

Теперь вернёмся к предложенному ранее варианту с макросом. Немного скорректируем его определение, а именно, будем принимать на вход последовательность выражений, в пределах которой искомый тип существует под именем `N`:
```rust
macro_rules! with_n {
    ($($inner:tt)*) => {{
        #[derive(Copy, Clone, Debug)]
        struct N;
        impl $crate::NatInner for N {}
        impl $crate::Nat for N {
            // тут реализация
        }
        $($inner)*
    }};
}
```
Обратите внимание, правая часть макроса содержит двойные фигурные скобки. За счёт этого генерируемый макросом код становится блоком и, во-первых, может использоваться как выражение - в частности, стоять в правой части оператора присваивания, - во-вторых, ограничивает область видимости определённых в нём элементов, в том числе и типа `N`, благодаря чему несколько вызовов `with_n` подряд не вызовут конфликтов.

Пора заниматься самой реализацией. В нынешнем проекте она была построена следующим образом: каждый такой макрос создаёт статическую структуру определённого типа - по сути, write-only вариант для `AtomicUsize`, которая будет хранить однажды записанное значение и выдавать его по запросу. Не будем разбирать реализацию - просто скажем, что она по большей части опирается на код, приведённый [здесь](https://users.rust-lang.org/t/write-once-static-option/35033), ограничимся только интерфейсом:
```rust
use thiserror::Error;

#[derive(Debug, Error)]
pub enum NatStoreError {
    // Ошибка для случая, когда несколько вызовов `store()` были запущены одновременно
    #[error("Attempted to concurrently create multiple instances of N: Nat")]
    Concurrent,
    // Ошибка для случая, когда мы попытались затереть уже сохранённое значение
    #[error("Attempted to override already stored value {0} with {1}")]
    AlreadyStored(usize, usize),
}

pub struct NatHolder { /* skipped */ }
impl NatHolder {
    pub const fn new() -> Self {
        // skipped
    }
    pub fn store(&self, value: usize) -> Result<(), NatStoreError> {
        // skipped
    }
    pub fn read(&self) -> Option<usize> {
        // skipped
    }
}
```
А теперь - реализация. Заодно мы немного расширим API наших натуральных чисел, а именно:
 - добавим возможность создавать объект, имея только тип, но не значение - это может пригодиться в обобщённом коде (хотя в нынешнем проекте эти методы не используются, но удалить их всё равно рука не поднялась);
 - добавим возможность получить значение, соответствующее типу, не имея самого объекта - это нам пригодится чуть позже.
 
 Собственно, реализация:
```rust
pub trait Nat: Sized + NatInner + Clone + Copy {
    fn get_usize() -> Option<usize>;
    fn as_usize(self) -> usize;
    fn from_usize(s: usize) -> Result<Self, crate::NatStoreError>;
    fn get() -> Self;
    fn try_get() -> Option<Self>;
}

#[macro_export]
macro_rules! with_n {
    ($($inner:tt)*) => {{
        // пропуск
        impl $crate::Nat for N {
            fn get_usize() -> Option<usize> {
                HOLDER.read()
            }
            fn as_usize(self) -> usize {
                // Этот вызов никогда не должен проваливаться,
                // т.к. раз объект создан, Holder должен быть уже инициализирован
                HOLDER.read().unwrap();
            }
            fn from_usize(s: usize) -> Result<Self, $crate::NatStoreError> {
                HOLDER.store(s).map(|_| Self)
            }
            fn get() -> Self {
                Self::try_get().expect("Trying to `get` the number which is yet undefined")
            }
            fn try_get() -> Option<Self> {
                Self::get_usize().map(|_| Self)
            }
        }
        $($inner)*
    }};
}
```
И ещё, забегая немного вперёд, во-первых, добавим небольшую функцию-утилиту - фактически, чуть более приятный вариант обычного `Result::unwrap`:
```rust
pub fn expect_nat<N: Nat>(s: usize) -> N {
    N::from_usize(s).unwrap_or_else(|err| panic!(format!("{}", err)))
}
```
А во-вторых, скорректируем определение `Equiv` с использованием нового API
```rust
impl<N1: Nat, N2: Nat> Equiv<N1, N2> {
    pub fn try_create() -> Option<Self> {
        N1::get_usize().and_then(|n1| {
            N2::get_usize().and_then(|n2| {
                if n1 == n2 {
                    Some(Self(PhantomData))
                } else {
                    None
                }
            })
        })
    }
    pub fn check(_: N1, _: N2) -> Option<Self> {
        Self::try_create()
    }
}
```
Пора возвращаться к нашим векторам!

### `qd_vect`: наконец-то создаём

Для создания вектора мы используем совершенно тривиальную обёртку над `with_n`:
```rust
#[macro_export]
macro_rules! vect {
    ($data:expr) => {
        ::qd_nat::with_n! {
            let v = $data;
            $crate::collect::<_, N, _>(v)
        }
    };
}
```
Работает эта конструкция предельно грубо и прямолинейно: запрашиваем свежий тип `N`, передаём его через "турборыбу" функции `collect`, в качестве аргумента ей скармливаем входные данные. На выходе получаем искомый `Vect<N, T>`.

Так как интерфейс типажа `Nat` изменился, немного поменяется и функция `collect`:
```rust
pub fn collect<Item, N: Nat, I: IntoIterator<Item = Item>>(
    iter: I,
) -> (N, Vect<Item, N>) {
    let inner: Vec<_> = iter.into_iter().collect();
    (expect_nat(inner.len()), Vect(inner, PhantomData))
}
```

Теперь вспомним про нашу тестовую функцию `zip_sum`. Она ожидает на входе два вектора одного и того же типа, с одним и тем же параметром `N`; в противном случае она не скомпилируется. Следовательно, нам нужна возможность каким-то образом приводить два вектора к одному типа, при условии, что они имеют равную длину - иначе мы эту операцию просто не вправе проводить. 